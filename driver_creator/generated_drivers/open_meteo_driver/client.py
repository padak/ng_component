"""
Open-Meteo Driver - Client Implementation

None driver for Open-Meteo following Driver Design v2.0 spec.

ðŸ¤– AUTO-GENERATED by Driver Creator Agent
ðŸ“… Generated: now

âœ… COMPLETE SECTIONS:
- BaseDriver inheritance
- Authentication
- Basic discovery methods (list_objects, get_fields)

- Error handling
- Retry logic with exponential backoff

âš ï¸ TODO SECTIONS:
- Review authentication edge cases

- Add integration tests with real API
- Optimize rate limiting strategy
"""

import os
import time
import requests
from typing import List, Dict, Any, Optional, Iterator
from enum import Enum
from dataclasses import dataclass

from .exceptions import (
    DriverError,
    AuthenticationError,
    ConnectionError,
    ObjectNotFoundError,
    FieldNotFoundError,
    QuerySyntaxError,
    RateLimitError,
    ValidationError,
    TimeoutError
)


class PaginationStyle(Enum):
    """How the driver handles pagination"""
    NONE = "none"
    OFFSET = "offset"          # LIMIT/OFFSET style (SQL)
    CURSOR = "cursor"          # Cursor-based (Salesforce, GraphQL)
    PAGE_NUMBER = "page"       # Page-based (REST APIs)
    TIME_BASED = "time_based"  # Time-based pagination (dates/timestamps)
    TIME_RANGE = "time_range"  # Time range pagination (start_date/end_date)


@dataclass
class DriverCapabilities:
    """What the driver can do"""
    read: bool = True
    write: bool = False
    update: bool = False
    delete: bool = False
    batch_operations: bool = False
    streaming: bool = False
    pagination: PaginationStyle = PaginationStyle.NONE
    query_language: Optional[str] = None
    max_page_size: Optional[int] = None
    supports_transactions: bool = False
    supports_relationships: bool = False


class OpenMeteoDriver:
    """
    Open-Meteo driver.

    Features:
    
    
    - Discovery methods (list_objects, get_fields)
    - Automatic retry on rate limits
    

    Example:
        >>> client = OpenMeteoDriver.from_env()
        >>> objects = client.list_objects()
        >>> fields = client.get_fields("Object")
        
    """

    def __init__(
        self,
        api_url: str,
        api_key: Optional[str] = None,
        timeout: int = 30,
        max_retries: int = 3,
        debug: bool = False,
        **kwargs
    ):
        """
        Initialize the Open-Meteo driver.

        Args:
            api_url: Base URL for API (https://open-meteo.com/en/docs)
            api_key: Authentication key/token
            timeout: Request timeout in seconds
            max_retries: Number of retry attempts for rate limiting
            debug: Enable debug logging (logs all API calls)
            **kwargs: Driver-specific options
        """
        self.api_url = api_url.rstrip('/')
        self.api_key = api_key
        self.timeout = timeout
        self.max_retries = max_retries
        self.debug = debug

        # Setup requests session
        self.session = requests.Session()
        self.session.headers.update(self._get_headers())

        # Validate credentials at init time (fail fast!)
        self._validate_connection()

    @classmethod
    def from_env(cls, **kwargs) -> 'OpenMeteoDriver':
        """
        Create driver instance from environment variables.

        Environment variables:
            OPEN_METEO_DRIVER_API_URL: API base URL
            OPEN_METEO_DRIVER_API_KEY: Authentication key

        Example:
            >>> # Set in .env file:
            >>> # OPEN_METEO_DRIVER_API_URL=https://open-meteo.com/en/docs
            >>> # OPEN_METEO_DRIVER_API_KEY=your_key_here
            >>> client = OpenMeteoDriver.from_env()

        Raises:
            AuthenticationError: If required env vars are missing
        """
        api_url = os.environ.get("OPEN_METEO_DRIVER_API_URL")
        api_key = os.environ.get("OPEN_METEO_DRIVER_API_KEY")

        if not api_url:
            raise AuthenticationError(
                "Missing OPEN_METEO_DRIVER_API_URL environment variable",
                details={"env_vars": ["OPEN_METEO_DRIVER_API_URL", "OPEN_METEO_DRIVER_API_KEY"]}
            )

        if not api_key:
            raise AuthenticationError(
                "Missing OPEN_METEO_DRIVER_API_KEY environment variable",
                details={"env_vars": ["OPEN_METEO_DRIVER_API_URL", "OPEN_METEO_DRIVER_API_KEY"]}
            )

        return cls(api_url=api_url, api_key=api_key, **kwargs)

    def get_capabilities(self) -> DriverCapabilities:
        """
        Return driver capabilities so agent knows what it can do.

        Returns:
            DriverCapabilities with boolean flags for features

        Example:
            >>> capabilities = client.get_capabilities()
            >>> if capabilities.write:
            ...     # Agent can generate create() calls
        """
        return DriverCapabilities(
            read=True,
            write=False,
            update=False,
            delete=False,
            batch_operations=False,
            streaming=False,
            pagination=PaginationStyle.NONE,
            query_language="None" if "None" else None,
            max_page_size=None,
            supports_transactions=False,
            supports_relationships=False
        )

    # Discovery Methods (REQUIRED)

    def list_objects(self) -> List[str]:
        """
        Discover all available objects/tables/entities.

        Returns:
            List of object names

        Example:
            >>> objects = client.list_objects()
            >>> print(objects)
            ['Event', 'Person', 'Session', ...]

        Raises:
            ConnectionError: If API is unreachable
            AuthenticationError: If credentials are invalid
        """
        # TODO: Implement based on API documentation
        # For Open-Meteo, this might be:
        
        # - Fetch from API metadata/schema endpoint
        # - Parse OpenAPI spec
        # - Query information_schema (for databases)
        

        try:
            # Placeholder implementation
            
            response = self._api_call("/schema", method="GET")
            return response.get("objects", [])
            

        except requests.HTTPError as e:
            if e.response.status_code == 404:
                raise ConnectionError(
                    "Open-Meteo API schema endpoint not found. Check api_url configuration.",
                    details={"api_url": self.api_url, "endpoint": "/schema"}
                )
            raise

    def get_fields(self, object_name: str) -> Dict[str, Any]:
        """
        Get complete field schema for an object.

        Args:
            object_name: Name of object (case-sensitive!)

        Returns:
            Dictionary with field definitions:
            {
                "field_name": {
                    "type": "string|integer|float|boolean|datetime|...",
                    "label": "Human-readable name",
                    "required": bool,
                    "nullable": bool
                }
            }

        Raises:
            ObjectNotFoundError: If object doesn't exist

        Example:
            >>> fields = client.get_fields("Event")
            >>> print(fields.keys())
            dict_keys(['id', 'timestamp', 'event_type', ...])
        """
        # TODO: Implement based on API documentation
        # For Open-Meteo, this might be:
        # - Fetch from /schema/<object_name> endpoint
        # - Parse object metadata
        # - Query information_schema (for databases)

        try:
            # Placeholder implementation
            response = self._api_call(f"/schema/{object_name}", method="GET")

            # Transform API response to standard format
            fields = {}
            for field in response.get("fields", []):
                fields[field["name"]] = {
                    "type": field.get("type", "string"),
                    "label": field.get("label", field["name"]),
                    "required": field.get("required", False),
                    "nullable": field.get("nullable", True)
                }

            return fields

        except requests.HTTPError as e:
            if e.response.status_code == 404:
                available = self.list_objects()
                raise ObjectNotFoundError(
                    f"Object '{object_name}' not found. Available objects: {', '.join(available[:5])}",
                    details={"requested": object_name, "available": available}
                )
            raise

    # Read Operations (REQUIRED)

    
    def read(
        self,
        query: str = "",
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> List[Dict[str, Any]]:
        """
        Read data from API (no query language - uses default endpoint).

        Args:
            query: Not used for REST APIs without query language
            limit: Maximum number of records to return
            offset: Number of records to skip (for pagination)

        Returns:
            List of dictionaries (one per record)

        Example:
            >>> results = client.read(limit=100)

        Note:
            For more control, use call_endpoint() method directly.
        """
        # For REST APIs without query language, this is a convenience method
        # that calls a default endpoint (e.g., /items, /records)

        params = {}
        if limit:
            params["limit"] = limit
        if offset:
            params["offset"] = offset

        response = self._api_call("/items", method="GET", params=params)
        return response.get("items", [])
    

    

    # Utility Methods

    def get_rate_limit_status(self) -> Dict[str, Any]:
        """
        Get current rate limit status (if supported by API).

        Returns:
            {
                "remaining": int,     # Requests remaining
                "limit": int,         # Total limit
                "reset_at": str,      # ISO timestamp when limit resets
                "retry_after": int    # Seconds to wait (if rate limited)
            }

        Example:
            >>> status = client.get_rate_limit_status()
            >>> if status["remaining"] < 10:
            ...     print("Warning: Only 10 API calls left!")
        """
        # TODO: Implement based on API's rate limit headers/endpoint
        # Common patterns:
        # - Parse X-RateLimit-* headers from last response
        # - Call dedicated /rate_limit endpoint
        # - Track locally (for APIs without explicit limits)

        return {
            "remaining": None,
            "limit": None,
            "reset_at": None,
            "retry_after": None
        }

    def close(self):
        """
        Close connections and cleanup resources.

        Example:
            >>> client = OpenMeteoDriver.from_env()
            >>> try:
            ...     results = client.read("SELECT * FROM table")
            >>> finally:
            ...     client.close()
        """
        if self.session:
            self.session.close()

    # Internal Methods

    def _get_headers(self) -> Dict[str, str]:
        """Get HTTP headers for API requests"""
        headers = {
            "Content-Type": "application/json",
            "Accept": "application/json"
        }

        

        return headers

    def _validate_connection(self):
        """
        Validate connection at __init__ time (fail fast!).

        Raises:
            AuthenticationError: Invalid credentials
            ConnectionError: Cannot reach API
        """
        try:
            # Try a simple API call to validate credentials
            self._api_call("/health", method="GET")

        except requests.HTTPError as e:
            if e.response.status_code in [401, 403]:
                raise AuthenticationError(
                    f"Invalid Open-Meteo credentials. Check your API key.",
                    details={"api_url": self.api_url}
                )
            elif e.response.status_code == 404:
                # /health endpoint might not exist - that's okay
                pass
            else:
                raise

        except requests.ConnectionError as e:
            raise ConnectionError(
                f"Cannot connect to Open-Meteo: {str(e)}",
                details={"api_url": self.api_url}
            )

    def _api_call(self, endpoint: str, method: str = "GET", **kwargs) -> Dict[str, Any]:
        """
        Make API call with automatic retry on rate limits.

        Args:
            endpoint: API endpoint path
            method: HTTP method
            **kwargs: Additional request arguments

        Returns:
            Response data as dictionary

        Raises:
            RateLimitError: After max_retries exhausted
            ConnectionError: Network issues
            AuthenticationError: Invalid credentials
        """
        url = f"{self.api_url}{endpoint}"

        for attempt in range(self.max_retries):
            try:
                if self.debug:
                    print(f"[DEBUG] {method} {url}")

                response = self.session.request(
                    method,
                    url,
                    timeout=self.timeout,
                    **kwargs
                )
                response.raise_for_status()

                # Try to parse JSON
                try:
                    return response.json()
                except ValueError:
                    # Non-JSON response
                    return {"data": response.text}

            except requests.HTTPError as e:
                if e.response.status_code == 429:
                    # Rate limited - retry with exponential backoff
                    retry_after = int(e.response.headers.get("Retry-After", 2 ** attempt))

                    if attempt < self.max_retries - 1:
                        if self.debug:
                            print(f"[DEBUG] Rate limited. Retrying in {retry_after}s (attempt {attempt+1}/{self.max_retries})")
                        time.sleep(retry_after)
                        continue
                    else:
                        raise RateLimitError(
                            f"API rate limit exceeded after {self.max_retries} attempts. Retry after {retry_after} seconds.",
                            details={
                                "retry_after": retry_after,
                                "attempts": self.max_retries,
                                
                            }
                        )

                # Other HTTP errors - don't retry
                raise

            except requests.Timeout:
                raise TimeoutError(
                    f"Request timed out after {self.timeout} seconds",
                    details={"timeout": self.timeout, "url": url}
                )

            except requests.ConnectionError as e:
                raise ConnectionError(
                    f"Cannot connect to Open-Meteo: {str(e)}",
                    details={"url": url}
                )