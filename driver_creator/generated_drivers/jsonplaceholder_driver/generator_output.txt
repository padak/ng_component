```json
{
    "files": {
        "client.py": "### FILE: client.py\n```python\n\"\"\"\nJSONPlaceholder Driver - Driver Design v2.0\n\nA complete driver for the JSONPlaceholder fake REST API.\nSupports all standard REST operations with discovery-first approach.\n\"\"\"\n\nimport time\nimport logging\nfrom typing import Dict, List, Any, Optional, Union\nfrom dataclasses import dataclass\nfrom enum import Enum\n\nimport requests\nfrom requests.adapters import HTTPAdapter\nfrom urllib3.util.retry import Retry\n\nfrom .exceptions import (\n    DriverError,\n    ConnectionError,\n    ObjectNotFoundError,\n    QuerySyntaxError,\n    RateLimitError,\n    ValidationError,\n)\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass OperationType(Enum):\n    \"\"\"Supported operation types.\"\"\"\n    READ = \"read\"\n    CREATE = \"create\"\n    UPDATE = \"update\"\n    DELETE = \"delete\"\n\n\n@dataclass\nclass DriverCapabilities:\n    \"\"\"Driver capabilities metadata.\"\"\"\n    supports_query: bool = True\n    supports_write: bool = True\n    supports_delete: bool = True\n    supports_pagination: bool = True\n    supports_filtering: bool = True\n    supports_sorting: bool = False\n    max_page_size: Optional[int] = None\n    requires_auth: bool = False\n    api_type: str = \"REST\"\n\n\nclass JsonplaceholderDriver:\n    \"\"\"\n    Driver for JSONPlaceholder API.\n    \n    JSONPlaceholder is a free fake REST API for testing and prototyping.\n    This driver provides a standardized interface following Driver Design v2.0.\n    \n    Attributes:\n        base_url: Base URL for the API (default: https://jsonplaceholder.typicode.com)\n        timeout: Request timeout in seconds\n        max_retries: Maximum number of retry attempts\n        session: Requests session with retry logic\n    \"\"\"\n    \n    DEFAULT_BASE_URL = \"https://jsonplaceholder.typicode.com\"\n    DEFAULT_TIMEOUT = 30\n    DEFAULT_MAX_RETRIES = 3\n    \n    # Known object types (resources) in JSONPlaceholder\n    KNOWN_OBJECTS = [\n        \"posts\",\n        \"comments\",\n        \"albums\",\n        \"photos\",\n        \"todos\",\n        \"users\",\n    ]\n    \n    def __init__(\n        self,\n        base_url: Optional[str] = None,\n        timeout: int = DEFAULT_TIMEOUT,\n        max_retries: int = DEFAULT_MAX_RETRIES,\n        verify_ssl: bool = True,\n    ):\n        \"\"\"\n        Initialize JSONPlaceholder driver.\n        \n        Args:\n            base_url: Base URL for the API (optional, uses default if not provided)\n            timeout: Request timeout in seconds\n            max_retries: Maximum number of retry attempts\n            verify_ssl: Whether to verify SSL certificates\n            \n        Raises:\n            ConnectionError: If unable to connect to the API\n        \"\"\"\n        self.base_url = (base_url or self.DEFAULT_BASE_URL).rstrip(\"/\")\n        self.timeout = timeout\n        self.max_retries = max_retries\n        self.verify_ssl = verify_ssl\n        \n        # Initialize session with retry logic\n        self.session = self._create_session()\n        \n        # Validate connection on initialization (fail fast!)\n        self._validate_connection()\n        \n        logger.info(f\"JSONPlaceholder driver initialized for {self.base_url}\")\n    \n    @classmethod\n    def from_env(cls) -> \"JsonplaceholderDriver\":\n        \"\"\"\n        Create driver instance from environment variables.\n        \n        Environment variables:\n            JSONPLACEHOLDER_BASE_URL: Base URL (optional)\n            JSONPLACEHOLDER_TIMEOUT: Request timeout in seconds (optional)\n            \n        Returns:\n            JsonplaceholderDriver instance\n        \"\"\"\n        import os\n        \n        base_url = os.getenv(\"JSONPLACEHOLDER_BASE_URL\")\n        timeout = int(os.getenv(\"JSONPLACEHOLDER_TIMEOUT\", cls.DEFAULT_TIMEOUT))\n        \n        return cls(base_url=base_url, timeout=timeout)\n    \n    def _create_session(self) -> requests.Session:\n        \"\"\"\n        Create requests session with retry logic.\n        \n        Returns:\n            Configured requests.Session\n        \"\"\"\n        session = requests.Session()\n        \n        # Configure retry strategy\n        retry_strategy = Retry(\n            total=self.max_retries,\n            backoff_factor=1,\n            status_forcelist=[429, 500, 502, 503, 504],\n            allowed_methods=[\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"],\n        )\n        \n        adapter = HTTPAdapter(max_retries=retry_strategy)\n        session.mount(\"http://\", adapter)\n        session.mount(\"https://\", adapter)\n        \n        # Set default headers\n        session.headers.update({\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n        })\n        \n        return session\n    \n    def _validate_connection(self) -> None:\n        \"\"\"\n        Validate connection to the API.\n        \n        Raises:\n            ConnectionError: If unable to connect to the API\n        \"\"\"\n        try:\n            # Try to fetch a simple endpoint to verify connectivity\n            response = self.session.get(\n                f\"{self.base_url}/posts/1\",\n                timeout=self.timeout,\n                verify=self.verify_ssl,\n            )\n            response.raise_for_status()\n            logger.info(\"Connection validated successfully\")\n        except requests.exceptions.RequestException as e:\n            logger.error(f\"Connection validation failed: {e}\")\n            raise ConnectionError(\n                f\"Failed to connect to JSONPlaceholder API at {self.base_url}: {str(e)}\"\n            ) from e\n    \n    def get_capabilities(self) -> DriverCapabilities:\n        \"\"\"\n        Get driver capabilities.\n        \n        Returns:\n            DriverCapabilities object describing what this driver supports\n        \"\"\"\n        return DriverCapabilities(\n            supports_query=True,\n            supports_write=True,\n            supports_delete=True,\n            supports_pagination=True,\n            supports_filtering=True,\n            supports_sorting=False,\n            max_page_size=None,  # No enforced limit\n            requires_auth=False,\n            api_type=\"REST\",\n        )\n    \n    def list_objects(self) -> List[str]:\n        \"\"\"\n        List all available object types (resources).\n        \n        Returns:\n            List of object type names\n            \n        Example:\n            >>> driver.list_objects()\n            ['posts', 'comments', 'albums', 'photos', 'todos', 'users']\n        \"\"\"\n        return self.KNOWN_OBJECTS.copy()\n    \n    def get_fields(self, object_name: str) -> Dict[str, Any]:\n        \"\"\"\n        Get field schema for an object type.\n        \n        Args:\n            object_name: Name of the object type (e.g., 'posts', 'users')\n            \n        Returns:\n            Dictionary mapping field names to field metadata\n            \n        Raises:\n            ObjectNotFoundError: If object type doesn't exist\n            \n        Example:\n            >>> driver.get_fields('posts')\n            {\n                'id': {'type': 'number', 'required': True},\n                'userId': {'type': 'number', 'required': True},\n                'title': {'type': 'string', 'required': True},\n                'body': {'type': 'string', 'required': True}\n            }\n        \"\"\"\n        if object_name not in self.KNOWN_OBJECTS:\n            raise ObjectNotFoundError(f\"Object type '{object_name}' not found\")\n        \n        # Fetch a sample record to discover schema\n        try:\n            sample_data = self._api_call(\"GET\", f\"/{object_name}\", params={\"_limit\": 1})\n            \n            if not sample_data or not isinstance(sample_data, list) or len(sample_data) == 0:\n                # Fallback to predefined schemas\n                return self._get_fallback_schema(object_name)\n            \n            # Infer schema from sample data\n            sample_record = sample_data[0]\n            return self._infer_schema(sample_record)\n            \n        except Exception as e:\n            logger.warning(f\"Failed to discover schema for {object_name}: {e}\")\n            return self._get_fallback_schema(object_name)\n    \n    def _infer_schema(self, record: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        Infer schema from a sample record.\n        \n        Args:\n            record: Sample data record\n            \n        Returns:\n            Schema dictionary\n        \"\"\"\n        schema = {}\n        \n        for key, value in record.items():\n            field_type = type(value).__name__\n            \n            # Map Python types to schema types\n            if isinstance(value, bool):\n                field_type = \"boolean\"\n            elif isinstance(value, int):\n                field_type = \"number\"\n            elif isinstance(value, float):\n                field_type = \"number\"\n            elif isinstance(value, str):\n                field_type = \"string\"\n            elif isinstance(value, dict):\n                field_type = \"object\"\n            elif isinstance(value, list):\n                field_type = \"array\"\n            else:\n                field_type = \"unknown\"\n            \n            schema[key] = {\n                \"type\": field_type,\n                \"required\": key == \"id\",  # ID is typically required\n            }\n        \n        return schema\n    \n    def _get_fallback_schema(self, object_name: str) -> Dict[str, Any]:\n        \"\"\"\n        Get predefined schema for known object types.\n        \n        Args:\n            object_name: Name of the object type\n            \n        Returns:\n            Schema dictionary\n        \"\"\"\n        schemas = {\n            \"posts\": {\n                \"id\": {\"type\": \"number\", \"required\": True},\n                \"userId\": {\"type\": \"number\", \"required\": True},\n                \"title\": {\"type\": \"string\", \"required\": True},\n                \"body\": {\"type\": \"string\", \"required\": True},\n            },\n            \"comments\": {\n                \"id\": {\"type\": \"number\", \"required\": True},\n                \"postId\": {\"type\": \"number\", \"required\": True},\n                \"name\": {\"type\": \"string\", \"required\": True},\n                \"email\": {\"type\": \"string\", \"required\": True},\n                \"body\": {\"type\": \"string\", \"required\": True},\n            },\n            \"albums\": {\n                \"id\": {\"type\": \"number\", \"required\": True},\n                \"userId\": {\"type\": \"number\", \"required\": True},\n                \"title\": {\"type\": \"string\", \"required\": True},\n            },\n            \"photos\": {\n                \"id\": {\"type\": \"number\", \"required\": True},\n                \"albumId\": {\"type\": \"number\", \"required\": True},\n                \"title\": {\"type\": \"string\", \"required\": True},\n                \"url\": {\"type\": \"string\", \"required\": True},\n                \"thumbnailUrl\": {\"type\": \"string\", \"required\": True},\n            },\n            \"todos\": {\n                \"id\": {\"type\": \"number\", \"required\": True},\n                \"userId\": {\"type\": \"number\", \"required\": True},\n                \"title\": {\"type\": \"string\", \"required\": True},\n                \"completed\": {\"type\": \"boolean\", \"required\": True},\n            },\n            \"users\": {\n                \"id\": {\"type\": \"number\", \"required\": True},\n                \"name\": {\"type\": \"string\", \"required\": True},\n                \"username\": {\"type\": \"string\", \"required\": True},\n                \"email\": {\"type\": \"string\", \"required\": True},\n                \"address\": {\"type\": \"object\", \"required\": False},\n                \"phone\": {\"type\": \"string\", \"required\": False},\n                \"website\": {\"type\": \"string\", \"required\": False},\n                \"company\": {\"type\": \"object\", \"required\": False},\n            },\n        }\n        \n        return schemas.get(object_name, {})\n    \n    def read(\n        self,\n        object_name: str,\n        filters: Optional[Dict[str, Any]] = None,\n        fields: Optional[List[str]] = None,\n        limit: Optional[int] = None,\n        page: Optional[int] = None,\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        Read records from an object type.\n        \n        Args:\n            object_name: Name of the object type (e.g., 'posts')\n            filters: Dictionary of filter criteria (e.g., {'userId': 1})\n            fields: List of fields to return (not supported by JSONPlaceholder)\n            limit: Maximum number of records to return\n            page: Page number for pagination (1-indexed)\n            \n        Returns:\n            List of records\n            \n        Raises:\n            ObjectNotFoundError: If object type doesn't exist\n            QuerySyntaxError: If query parameters are invalid\n            \n        Example:\n            >>> driver.read('posts', filters={'userId': 1}, limit=5)\n            [{'id': 1, 'userId': 1, 'title': '...', 'body': '...'}, ...]\n        \"\"\"\n        if object_name not in self.KNOWN_OBJECTS:\n            raise ObjectNotFoundError(f\"Object type '{object_name}' not found\")\n        \n        # Build query parameters\n        params = {}\n        \n        if filters:\n            params.update(filters)\n        \n        if limit:\n            params[\"_limit\"] = limit\n        \n        if page:\n            params[\"_page\"] = page\n        \n        # Make API call\n        try:\n            data = self._api_call(\"GET\", f\"/{object_name}\", params=params)\n            \n            # JSONPlaceholder always returns arrays for collection endpoints\n            if not isinstance(data, list):\n                data = [data]\n            \n            return data\n            \n        except Exception as e:\n            logger.error(f\"Failed to read from {object_name}: {e}\")\n            raise\n    \n    def read_by_id(\n        self,\n        object_name: str,\n        record_id: Union[int, str],\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Read a single record by ID.\n        \n        Args:\n            object_name: Name of the object type\n            record_id: ID of the record to fetch\n            \n        Returns:\n            Single record dictionary\n            \n        Raises:\n            ObjectNotFoundError: If object or record doesn't exist\n            \n        Example:\n            >>> driver.read_by_id('posts', 1)\n            {'id': 1, 'userId': 1, 'title': '...', 'body': '...'}\n        \"\"\"\n        if object_name not in self.KNOWN_OBJECTS:\n            raise ObjectNotFoundError(f\"Object type '{object_name}' not found\")\n        \n        try:\n            data = self._api_call(\"GET\", f\"/{object_name}/{record_id}\")\n            return data\n        except Exception as e:\n            logger.error(f\"Failed to read {object_name}/{record_id}: {e}\")\n            raise\n    \n    def create(\n        self,\n        object_name: str,\n        data: Dict[str, Any],\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Create a new record.\n        \n        Note: JSONPlaceholder fakes POST requests - data won't actually persist.\n        \n        Args:\n            object_name: Name of the object type\n            data: Record data to create\n            \n        Returns:\n            Created record with generated ID\n            \n        Raises:\n            ObjectNotFoundError: If object type doesn't exist\n            ValidationError: If data is invalid\n            \n        Example:\n            >>> driver.create('posts', {\n            ...     'title': 'New Post',\n            ...     'body': 'Content',\n            ...     'userId': 1\n            ... })\n            {'id': 101, 'title': 'New Post', 'body': 'Content', 'userId': 1}\n        \"\"\"\n        if object_name not in self.KNOWN_OBJECTS:\n            raise ObjectNotFoundError(f\"Object type '{object_name}' not found\")\n        \n        try:\n            result = self._api_call(\"POST\", f\"/{object_name}\", json_data=data)\n            return result\n        except Exception as e:\n            logger.error(f\"Failed to create record in {object_name}: {e}\")\n            raise\n    \n    def update(\n        self,\n        object_name: str,\n        record_id: Union[int, str],\n        data: Dict[str, Any],\n        partial: bool = False,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Update an existing record.\n        \n        Note: JSONPlaceholder fakes PUT/PATCH requests - data won't actually persist.\n        \n        Args:\n            object_name: Name of the object type\n            record_id: ID of the record to update\n            data: Updated record data\n            partial: If True, use PATCH (partial update), otherwise PUT (full replacement)\n            \n        Returns:\n            Updated record\n            \n        Raises:\n            ObjectNotFoundError: If object or record doesn't exist\n            ValidationError: If data is invalid\n            \n        Example:\n            >>> driver.update('posts', 1, {'title': 'Updated Title'}, partial=True)\n            {'id': 1, 'title': 'Updated Title', ...}\n        \"\"\"\n        if object_name not in self.KNOWN_OBJECTS:\n            raise ObjectNotFoundError(f\"Object type '{object_name}' not found\")\n        \n        method = \"PATCH\" if partial else \"PUT\"\n        \n        try:\n            result = self._api_call(\n                method,\n                f\"/{object_name}/{record_id}\",\n                json_data=data,\n            )\n            return result\n        except Exception as e:\n            logger.error(f\"Failed to update {object_name}/{record_id}: {e}\")\n            raise\n    \n    def delete(\n        self,\n        object_name: str,\n        record_id: Union[int, str],\n    ) -> bool:\n        \"\"\"\n        Delete a record.\n        \n        Note: JSONPlaceholder fakes DELETE requests - data won't actually be deleted.\n        \n        Args:\n            object_name: Name of the object type\n            record_id: ID of the record to delete\n            \n        Returns:\n            True if successful\n            \n        Raises:\n            ObjectNotFoundError: If object or record doesn't exist\n            \n        Example:\n            >>> driver.delete('posts', 1)\n            True\n        \"\"\"\n        if object_name not in self.KNOWN_OBJECTS:\n            raise ObjectNotFoundError(f\"Object type '{object_name}' not found\")\n        \n        try:\n            self._api_call(\"DELETE\", f\"/{object_name}/{record_id}\")\n            return True\n        except Exception as e:\n            logger.error(f\"Failed to delete {object_name}/{record_id}: {e}\")\n            raise\n    \n    def get_nested(\n        self,\n        parent_object: str,\n        parent_id: Union[int, str],\n        nested_object: str,\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        Get nested resources (e.g., comments for a post).\n        \n        Args:\n            parent_object: Parent object type (e.g., 'posts')\n            parent_id: ID of the parent record\n            nested_object: Nested object type (e.g., 'comments')\n            \n        Returns:\n            List of nested records\n            \n        Example:\n            >>> driver.get_nested('posts', 1, 'comments')\n            [{'postId': 1, 'id': 1, 'name': '...', ...}, ...]\n        \"\"\"\n        path = f\"/{parent_object}/{parent_id}/{nested_object}\"\n        \n        try:\n            data = self._api_call(\"GET\", path)\n            if not isinstance(data, list):\n                data = [data]\n            return data\n        except Exception as e:\n            logger.error(f\"Failed to get nested resources from {path}: {e}\")\n            raise\n    \n    def query(\n        self,\n        object_name: str,\n        query_params: Optional[Dict[str, Any]] = None,\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        Query records with flexible parameters.\n        \n        This is an alias for read() that accepts arbitrary query parameters.\n        \n        Args:\n            object_name: Name of the object type\n            query_params: Dictionary of query parameters\n            \n        Returns:\n            List of matching records\n            \n        Example:\n            >>> driver.query('comments', {'postId': 1})\n            [{'postId': 1, 'id': 1, ...}, ...]\n        \"\"\"\n        return self.read(object_name, filters=query_params)\n    \n    def _api_call(\n        self,\n        method: str,\n        path: str,\n        params: Optional[Dict[str, Any]] = None,\n        json_data: Optional[Dict[str, Any]] = None,\n    ) -> Any:\n        \"\"\"\n        Make an API call with retry logic and error handling.\n        \n        Args:\n            method: HTTP method (GET, POST, PUT, PATCH, DELETE)\n            path: API endpoint path (should start with /)\n            params: Query parameters\n            json_data: JSON body data for POST/PUT/PATCH\n            \n        Returns:\n            Response data (parsed JSON)\n            \n        Raises:\n            ConnectionError: If request fails\n            ObjectNotFoundError: If resource not found (404)\n            RateLimitError: If rate limited (429)\n            DriverError: For other errors\n        \"\"\"\n        url = f\"{self.base_url}{path}\"\n        \n        logger.debug(f\"API call: {method} {url}\")\n        \n        try:\n            response = self.session.request(\n                method=method,\n                url=url,\n                params=params,\n                json=json_data,\n                timeout=self.timeout,\n                verify=self.verify_ssl,\n            )\n            \n            # Handle different status codes\n            if response.status_code == 404:\n                raise ObjectNotFoundError(f\"Resource not found: {path}\")\n            elif response.status_code == 429:\n                raise RateLimitError(\"Rate limit exceeded\")\n            elif response.status_code >= 500:\n                raise ConnectionError(\n                    f\"Server error ({response.status_code}): {response.text}\"\n                )\n            \n            response.raise_for_status()\n            \n            # Parse response\n            if response.status_code == 204 or not response.content:\n                return {}\n            \n            return response.json()\n            \n        except requests.exceptions.Timeout as e:\n            logger.error(f\"Request timeout: {e}\")\n            raise ConnectionError(f\"Request timeout: {str(e)}\") from e\n        except requests.exceptions.RequestException as e:\n            logger.error(f\"Request failed: {e}\")\n            raise ConnectionError(f\"Request failed: {str(e)}\") from e\n        except ValueError as e:\n            logger.error(f\"Failed to parse JSON response: {e}\")\n            raise DriverError(f\"Invalid JSON response: {str(e)}\") from e\n    \n    def close(self) -> None:\n        \"\"\"\n        Close the driver and cleanup resources.\n        \"\"\"\n        if self.session:\n            self.session.close()\n            logger.info(\"Driver session closed\")\n    \n    def __enter__(self) -> \"JsonplaceholderDriver\":\n        \"\"\"Context manager entry.\"\"\"\n        return self\n    \n    def __exit__(self, exc_type, exc_val, exc_tb) -> None:\n        \"\"\"Context manager exit.\"\"\"\n        self.close()\n    \n    def __repr__(self) -> str:\n        \"\"\"String representation.\"\"\"\n        return f\"JsonplaceholderDriver(base_url='{self.base_url}')\"\n```",
        "__init__.py": "### FILE: __init__.py\n```python\n\"\"\"\nJSONPlaceholder Driver - A complete driver for the JSONPlaceholder API.\n\nThis package provides a standardized interface to interact with the\nJSONPlaceholder fake REST API following Driver Design v2.0 principles.\n\"\"\"\n\nfrom .client import (\n    JsonplaceholderDriver,\n    DriverCapabilities,\n    OperationType,\n)\nfrom .exceptions import (\n    DriverError,\n    AuthenticationError,\n    ConnectionError,\n    ObjectNotFoundError,\n    QuerySyntaxError,\n    RateLimitError,\n    ValidationError,\n)\n\n__version__ = \"1.0.0\"\n__author__ = \"Driver Design Team\"\n__license__ = \"MIT\"\n\n__all__ = [\n    # Main driver class\n    \"JsonplaceholderDriver\",\n    \n    # Capabilities and enums\n    \"DriverCapabilities\",\n    \"OperationType\",\n    \n    # Exceptions\n    \"DriverError\",\n    \"AuthenticationError\",\n    \"ConnectionError\",\n    \"ObjectNotFoundError\",\n    \"QuerySyntaxError\",\n    \"RateLimitError\",\n    \"ValidationError\",\n    \n    # Metadata\n    \"__version__\",\n]\n```",
        "exceptions.py": "### FILE: exceptions.py\n```python\n\"\"\"\nCustom exceptions for JSONPlaceholder Driver.\n\nProvides a hierarchy of exceptions for different error scenarios.\n\"\"\"\n\n\nclass DriverError(Exception):\n    \"\"\"\n    Base exception for all driver errors.\n    \n    All custom exceptions inherit from this class.\n    \"\"\"\n    pass\n\n\nclass AuthenticationError(DriverError):\n    \"\"\"\n    Raised when authentication fails.\n    \n    Note: JSONPlaceholder doesn't require authentication,\n    but this is included for consistency with Driver Design v2.0.\n    \"\"\"\n    pass\n\n\nclass ConnectionError(DriverError):\n    \"\"\"\n    Raised when connection to the API fails.\n    \n    This includes:\n    - Network errors\n    - Timeouts\n    - Server errors (5xx)\n    - DNS resolution failures\n    \"\"\"\n    pass\n\n\nclass ObjectNotFoundError(DriverError):\n    \"\"\"\n    Raised when a requested object or resource is not found.\n    \n    This typically corresponds to HTTP 404 errors.\n    \n    Examples:\n    - Requesting an unknown object type\n    - Requesting a record ID that doesn't exist\n    \"\"\"\n    pass\n\n\nclass QuerySyntaxError(DriverError):\n    \"\"\"\n    Raised when a query has invalid syntax.\n    \n    Examples:\n    - Invalid filter parameters\n    - Malformed query structure\n    - Unsupported query operations\n    \"\"\"\n    pass\n\n\nclass RateLimitError(DriverError):\n    \"\"\"\n    Raised when API rate limit is exceeded.\n    \n    Note: JSONPlaceholder doesn't enforce rate limits,\n    but this is included for completeness.\n    \n    This typically corresponds to HTTP 429 errors.\n    \"\"\"\n    pass\n\n\nclass ValidationError(DriverError):\n    \"\"\"\n    Raised when data validation fails.\n    \n    Examples:\n    - Missing required fields\n    - Invalid field types\n    - Field values outside allowed range\n    \"\"\"\n    pass\n\n\nclass PermissionError(DriverError):\n    \"\"\"\n    Raised when operation is not permitted.\n    \n    This typically corresponds to HTTP 403 errors.\n    \n    Examples:\n    - Attempting to access restricted resources\n    - Insufficient permissions for operation\n    \"\"\"\n    pass\n\n\nclass TimeoutError(ConnectionError):\n    \"\"\"\n    Raised when a request times out.\n    \n    This is a specific type of ConnectionError for timeout scenarios.\n    \"\"\"\n    pass\n\n\nclass ServerError(DriverError):\n    \"\"\"\n    Raised when the API server returns an error.\n    \n    This typically corresponds to HTTP 5xx errors.\n    \"\"\"\n    pass\n```",
        "README.md": "### FILE: README.md\n```markdown\n# JSONPlaceholder Driver\n\nA complete, production-ready driver for the JSONPlaceholder API following Driver Design v2.0 principles.\n\n## Overview\n\n