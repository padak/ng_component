"""
{{ api_name }} Driver - Client Implementation

{{ api_type }} driver for {{ api_name }} following Driver Design v2.0 spec.

ðŸ¤– AUTO-GENERATED by Driver Creator Agent
ðŸ“… Generated: {{ "now" }}

âœ… COMPLETE SECTIONS:
- BaseDriver inheritance
- Authentication
- Basic discovery methods (list_objects, get_fields)
{% if query_language %}- Query execution ({{ query_language }}){% endif %}
- Error handling
- Retry logic with exponential backoff

âœ… COMPLETE IMPLEMENTATION:
- All methods have working default implementations
- Customize based on your specific API documentation
- Override methods in subclass if needed
"""

import os
import time
import requests
from typing import List, Dict, Any, Optional, Iterator
from enum import Enum
from dataclasses import dataclass

from .exceptions import (
    DriverError,
    AuthenticationError,
    ConnectionError,
    ObjectNotFoundError,
    FieldNotFoundError,
    QuerySyntaxError,
    RateLimitError,
    ValidationError,
    TimeoutError
)


class PaginationStyle(Enum):
    """How the driver handles pagination"""
    NONE = "none"
    OFFSET = "offset"          # LIMIT/OFFSET style (SQL)
    CURSOR = "cursor"          # Cursor-based (Salesforce, GraphQL)
    PAGE_NUMBER = "page"       # Page-based (REST APIs)
    TIME_BASED = "time_based"  # Time-based pagination (dates/timestamps)
    TIME_RANGE = "time_range"  # Time range pagination (start_date/end_date)


@dataclass
class DriverCapabilities:
    """What the driver can do"""
    read: bool = True
    write: bool = False
    update: bool = False
    delete: bool = False
    batch_operations: bool = False
    streaming: bool = False
    pagination: PaginationStyle = PaginationStyle.NONE
    query_language: Optional[str] = None
    max_page_size: Optional[int] = None
    supports_transactions: bool = False
    supports_relationships: bool = False


class {{ driver_class }}:
    """
    {{ api_name }} driver.

    Features:
    {% if query_language %}- {{ query_language }} query execution{% endif %}
    {% if api_type == "REST" %}- REST API endpoint calls{% endif %}
    - Discovery methods (list_objects, get_fields)
    - Automatic retry on rate limits
    {% if pagination_style and pagination_style != "none" %}- {{ pagination_style.capitalize() }}-based pagination{% endif %}

    Example:
        >>> client = {{ driver_class }}.from_env()
        >>> objects = client.list_objects()
        >>> fields = client.get_fields("Object")
        {% if query_language %}>>> results = client.read("SELECT * FROM object LIMIT 10"){% endif %}
    """

    def __init__(
        self,
        api_url: str,
        api_key: Optional[str] = None,
        timeout: int = 30,
        max_retries: int = 3,
        debug: bool = False,
        **kwargs
    ):
        """
        Initialize the {{ api_name }} driver.

        Args:
            api_url: Base URL for API ({{ base_url }})
            api_key: Authentication key/token
            timeout: Request timeout in seconds
            max_retries: Number of retry attempts for rate limiting
            debug: Enable debug logging (logs all API calls)
            **kwargs: Driver-specific options
        """
        self.api_url = api_url.rstrip('/')
        self.api_key = api_key
        self.timeout = timeout
        self.max_retries = max_retries
        self.debug = debug

        # Setup requests session
        self.session = requests.Session()
        self.session.headers.update(self._get_headers())

        # Validate credentials at init time (fail fast!)
        self._validate_connection()

    @classmethod
    def from_env(cls, **kwargs) -> '{{ driver_class }}':
        """
        Create driver instance from environment variables.

        Environment variables:
            {{ driver_name.upper() }}_API_URL: API base URL
            {{ driver_name.upper() }}_API_KEY: Authentication key

        Example:
            >>> # Set in .env file:
            >>> # {{ driver_name.upper() }}_API_URL={{ base_url }}
            >>> # {{ driver_name.upper() }}_API_KEY=your_key_here
            >>> client = {{ driver_class }}.from_env()

        Raises:
            AuthenticationError: If required env vars are missing
        """
        api_url = os.environ.get("{{ driver_name.upper() }}_API_URL")
        api_key = os.environ.get("{{ driver_name.upper() }}_API_KEY")

        if not api_url:
            raise AuthenticationError(
                "Missing {{ driver_name.upper() }}_API_URL environment variable",
                details={"env_vars": ["{{ driver_name.upper() }}_API_URL", "{{ driver_name.upper() }}_API_KEY"]}
            )

        if not api_key:
            raise AuthenticationError(
                "Missing {{ driver_name.upper() }}_API_KEY environment variable",
                details={"env_vars": ["{{ driver_name.upper() }}_API_URL", "{{ driver_name.upper() }}_API_KEY"]}
            )

        return cls(api_url=api_url, api_key=api_key, **kwargs)

    def get_capabilities(self) -> DriverCapabilities:
        """
        Return driver capabilities so agent knows what it can do.

        Returns:
            DriverCapabilities with boolean flags for features

        Example:
            >>> capabilities = client.get_capabilities()
            >>> if capabilities.write:
            ...     # Agent can generate create() calls
        """
        return DriverCapabilities(
            read=True,
            write={{ "True" if supports_write else "False" }},
            update=False,
            delete={{ "True" if supports_delete else "False" }},
            batch_operations=False,
            streaming=False,
            pagination=PaginationStyle.{{ pagination_style.upper() if pagination_style else "NONE" }},
            query_language="{{ query_language }}" if "{{ query_language }}" else None,
            max_page_size={% if pagination_style == "cursor" %}2000{% elif pagination_style == "offset" %}1000{% else %}None{% endif %},
            supports_transactions=False,
            supports_relationships=False
        )

    # Discovery Methods (REQUIRED)

    def list_objects(self) -> List[str]:
        """
        Discover all available objects/tables/entities.

        Returns:
            List of object names

        Example:
            >>> objects = client.list_objects()
            >>> print(objects)
            ['Event', 'Person', 'Session', ...]

        Raises:
            ConnectionError: If API is unreachable
            AuthenticationError: If credentials are invalid
        """
        try:
            {% if api_type == "REST" %}
            # For REST APIs without schema endpoint, try common patterns:
            # 1. Fetch from /schema or /metadata endpoint
            # 2. Return hardcoded list of known objects

            # Try schema endpoint first
            try:
                response = self._api_call("/schema", method="GET")
                if "objects" in response:
                    return response.get("objects", [])
                elif "tables" in response:
                    return response.get("tables", [])
            except Exception:
                pass  # Schema endpoint not available

            # Fallback: Return empty list (users should override this method)
            # Note: For production use, implement based on specific API documentation
            return []
            {% elif api_type == "GraphQL" %}
            # GraphQL introspection query
            {% raw %}
            introspection_query = """
            {
                __schema {
                    types {
                        name
                        kind
                    }
                }
            }
            """
            {% endraw %}
            response = self._api_call("/graphql", method="POST", json={"query": introspection_query})
            types = response.get("data", {}).get("__schema", {}).get("types", [])
            # Filter for OBJECT types only (exclude scalars, interfaces, etc.)
            return [t["name"] for t in types if t["kind"] == "OBJECT" and not t["name"].startswith("__")]
            {% else %}
            # Default implementation - override in subclass for specific API
            return []
            {% endif %}

        except requests.HTTPError as e:
            if e.response.status_code == 404:
                raise ConnectionError(
                    "{{ api_name }} API schema endpoint not found. This API may not support automatic discovery.",
                    details={"api_url": self.api_url}
                )
            raise

    def get_fields(self, object_name: str) -> Dict[str, Any]:
        """
        Get complete field schema for an object.

        Args:
            object_name: Name of object (case-sensitive!)

        Returns:
            Dictionary with field definitions:
            {
                "field_name": {
                    "type": "string|integer|float|boolean|datetime|...",
                    "label": "Human-readable name",
                    "required": bool,
                    "nullable": bool
                }
            }

        Raises:
            ObjectNotFoundError: If object doesn't exist

        Example:
            >>> fields = client.get_fields("Event")
            >>> print(fields.keys())
            dict_keys(['id', 'timestamp', 'event_type', ...])
        """
        {% if api_type == "REST" %}
        try:
            # Try schema endpoint
            response = self._api_call(f"/schema/{object_name}", method="GET")

            # Parse field schema from response
            fields = {}
            if "fields" in response:
                for field in response.get("fields", []):
                    fields[field["name"]] = {
                        "type": field.get("type", "string"),
                        "label": field.get("label", field["name"]),
                        "required": field.get("required", False),
                        "nullable": field.get("nullable", True)
                    }
            else:
                # Response might be the schema directly
                fields = response

            return fields

        except requests.HTTPError as e:
            if e.response.status_code == 404:
                # Schema endpoint not available - try fetching sample data
                try:
                    sample = self._api_call(f"/{object_name}?limit=1", method="GET")
                    if isinstance(sample, list) and len(sample) > 0:
                        # Infer schema from first record
                        record = sample[0]
                        fields = {}
                        for key, value in record.items():
                            fields[key] = {
                                "type": type(value).__name__,
                                "label": key,
                                "required": False,
                                "nullable": True
                            }
                        return fields
                except Exception:
                    pass

                available = self.list_objects()
                raise ObjectNotFoundError(
                    f"Object '{object_name}' not found. Available objects: {', '.join(available[:5])}...",
                    details={"requested": object_name, "available": available}
                )
            raise
        {% elif api_type == "GraphQL" %}
        # GraphQL type introspection
        {% raw %}
        introspection_query = f"""
        {{
            __type(name: "{object_name}") {{
                fields {{
                    name
                    type {{
                        name
                        kind
                    }}
                }}
            }}
        }}
        """
        {% endraw %}
        response = self._api_call("/graphql", method="POST", json={"query": introspection_query})
        type_info = response.get("data", {}).get("__type", {})

        if not type_info:
            raise ObjectNotFoundError(f"Type '{object_name}' not found in GraphQL schema")

        fields = {}
        for field in type_info.get("fields", []):
            fields[field["name"]] = {
                "type": field["type"]["name"],
                "label": field["name"],
                "required": field["type"]["kind"] == "NON_NULL",
                "nullable": field["type"]["kind"] != "NON_NULL"
            }

        return fields
        {% else %}
        # Default: Return empty dict - override in subclass
        return {}
        {% endif %}

    # Read Operations (REQUIRED)

    {% if query_language %}
    def read(
        self,
        query: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> List[Dict[str, Any]]:
        """
        Execute a {{ query_language }} query and return results.

        Args:
            query: Query in {{ query_language }} syntax
            limit: Maximum number of records to return
            offset: Number of records to skip (for pagination)

        Returns:
            List of dictionaries (one per record)

        Raises:
            QuerySyntaxError: Invalid query syntax
            RateLimitError: API rate limit exceeded (after retries)

        Example:
            >>> results = client.read("SELECT id, event FROM Event LIMIT 100")
            >>> print(f"Found {len(results)} records")
        """
        # Add limit/offset if provided
        modified_query = query
        if limit:
            modified_query += f" LIMIT {limit}"
        if offset:
            modified_query += f" OFFSET {offset}"

        try:
            # Placeholder implementation
            response = self._api_call(
                "/query",
                method="POST",
                json={"query": modified_query}
            )

            return response.get("results", [])

        except requests.HTTPError as e:
            if e.response.status_code == 400:
                error_data = e.response.json()
                raise QuerySyntaxError(
                    f"{{ query_language }} syntax error: {error_data.get('message', 'Unknown error')}",
                    details={"query": query}
                )
            raise
    {% else %}
    def read(
        self,
        query: str = "",
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> List[Dict[str, Any]]:
        """
        Read data from API (no query language - uses default endpoint).

        Args:
            query: Not used for REST APIs without query language
            limit: Maximum number of records to return
            offset: Number of records to skip (for pagination)

        Returns:
            List of dictionaries (one per record)

        Example:
            >>> results = client.read(limit=100)

        Note:
            For more control, use call_endpoint() method directly.
        """
        # For REST APIs without query language, this is a convenience method
        # that calls a default endpoint (e.g., /items, /records)

        params = {}
        if limit:
            params["limit"] = limit
        if offset:
            params["offset"] = offset

        response = self._api_call("/items", method="GET", params=params)
        return response.get("items", [])
    {% endif %}

    {% if api_type == "REST" %}
    # Low-Level API (for REST APIs)

    def call_endpoint(
        self,
        endpoint: str,
        method: str = "GET",
        params: Optional[Dict[str, Any]] = None,
        data: Optional[Dict[str, Any]] = None,
        **kwargs
    ) -> Dict[str, Any]:
        """
        Call a REST API endpoint directly (low-level access).

        Args:
            endpoint: API endpoint path (e.g., "/events")
            method: HTTP method ("GET", "POST", "PUT", "DELETE")
            params: URL query parameters
            data: Request body (for POST/PUT)
            **kwargs: Additional request options

        Returns:
            Response data as dictionary

        Example:
            >>> result = client.call_endpoint(
            ...     endpoint="/events",
            ...     method="GET",
            ...     params={"start_date": "2024-01-01", "limit": 100}
            ... )
        """
        return self._api_call(endpoint, method=method, params=params, json=data, **kwargs)
    {% endif %}

    # Utility Methods

    def get_rate_limit_status(self) -> Dict[str, Any]:
        """
        Get current rate limit status (if supported by API).

        Returns:
            {
                "remaining": int,     # Requests remaining
                "limit": int,         # Total limit
                "reset_at": str,      # ISO timestamp when limit resets
                "retry_after": int    # Seconds to wait (if rate limited)
            }

        Example:
            >>> status = client.get_rate_limit_status()
            >>> if status["remaining"] < 10:
            ...     print("Warning: Only 10 API calls left!")
        """
        # Check if we have a last response with rate limit headers
        if hasattr(self, '_last_response') and self._last_response:
            headers = self._last_response.headers

            # Common rate limit header patterns
            remaining = (
                headers.get('X-RateLimit-Remaining') or
                headers.get('X-Rate-Limit-Remaining') or
                headers.get('RateLimit-Remaining')
            )

            limit = (
                headers.get('X-RateLimit-Limit') or
                headers.get('X-Rate-Limit-Limit') or
                headers.get('RateLimit-Limit')
            )

            reset_at = (
                headers.get('X-RateLimit-Reset') or
                headers.get('X-Rate-Limit-Reset') or
                headers.get('RateLimit-Reset')
            )

            retry_after = headers.get('Retry-After')

            return {
                "remaining": int(remaining) if remaining else None,
                "limit": int(limit) if limit else None,
                "reset_at": reset_at,
                "retry_after": int(retry_after) if retry_after else None
            }

        # Try dedicated rate limit endpoint (some APIs have this)
        try:
            response = self._api_call("/rate_limit", method="GET")
            return response
        except Exception:
            pass  # Rate limit endpoint not available

        # Return None values if rate limiting not supported
        return {
            "remaining": None,
            "limit": None,
            "reset_at": None,
            "retry_after": None
        }

    def close(self):
        """
        Close connections and cleanup resources.

        Example:
            >>> client = {{ driver_class }}.from_env()
            >>> try:
            ...     results = client.read("SELECT * FROM table")
            >>> finally:
            ...     client.close()
        """
        if self.session:
            self.session.close()

    # Internal Methods

    def _get_headers(self) -> Dict[str, str]:
        """Get HTTP headers for API requests"""
        headers = {
            "Content-Type": "application/json",
            "Accept": "application/json"
        }

        {% if "api_key" in auth_methods %}
        if self.api_key:
            # Using Bearer token authentication (most common pattern)
            # Override this method if your API uses different auth headers:
            # - Token: Authorization: Token {api_key}
            # - API Key header: X-API-Key: {api_key}
            headers["Authorization"] = f"Bearer {self.api_key}"
        {% endif %}

        return headers

    def _validate_connection(self):
        """
        Validate connection at __init__ time (fail fast!).

        Raises:
            AuthenticationError: Invalid credentials
            ConnectionError: Cannot reach API
        """
        try:
            # Try a simple API call to validate credentials
            self._api_call("/health", method="GET")

        except requests.HTTPError as e:
            if e.response.status_code in [401, 403]:
                raise AuthenticationError(
                    f"Invalid {{ api_name }} credentials. Check your API key.",
                    details={"api_url": self.api_url}
                )
            elif e.response.status_code == 404:
                # /health endpoint might not exist - that's okay
                pass
            else:
                raise

        except requests.ConnectionError as e:
            raise ConnectionError(
                f"Cannot connect to {{ api_name }}: {str(e)}",
                details={"api_url": self.api_url}
            )

    def _api_call(self, endpoint: str, method: str = "GET", **kwargs) -> Dict[str, Any]:
        """
        Make API call with automatic retry on rate limits.

        Args:
            endpoint: API endpoint path
            method: HTTP method
            **kwargs: Additional request arguments

        Returns:
            Response data as dictionary

        Raises:
            RateLimitError: After max_retries exhausted
            ConnectionError: Network issues
            AuthenticationError: Invalid credentials
        """
        url = f"{self.api_url}{endpoint}"

        for attempt in range(self.max_retries):
            try:
                if self.debug:
                    print(f"[DEBUG] {method} {url}")

                response = self.session.request(
                    method,
                    url,
                    timeout=self.timeout,
                    **kwargs
                )
                response.raise_for_status()

                # Store response for rate limit header access
                self._last_response = response

                # Try to parse JSON
                try:
                    return response.json()
                except ValueError:
                    # Non-JSON response
                    return {"data": response.text}

            except requests.HTTPError as e:
                if e.response.status_code == 429:
                    # Rate limited - retry with exponential backoff
                    retry_after = int(e.response.headers.get("Retry-After", 2 ** attempt))

                    if attempt < self.max_retries - 1:
                        if self.debug:
                            print(f"[DEBUG] Rate limited. Retrying in {retry_after}s (attempt {attempt+1}/{self.max_retries})")
                        time.sleep(retry_after)
                        continue
                    else:
                        raise RateLimitError(
                            f"API rate limit exceeded after {self.max_retries} attempts. Retry after {retry_after} seconds.",
                            details={
                                "retry_after": retry_after,
                                "attempts": self.max_retries,
                                {% if rate_limit %}"rate_limit": "{{ rate_limit }}"{% endif %}
                            }
                        )

                # Other HTTP errors - don't retry
                raise

            except requests.Timeout:
                raise TimeoutError(
                    f"Request timed out after {self.timeout} seconds",
                    details={"timeout": self.timeout, "url": url}
                )

            except requests.ConnectionError as e:
                raise ConnectionError(
                    f"Cannot connect to {{ api_name }}: {str(e)}",
                    details={"url": url}
                )
