"""
{{ api_name }} Driver - Unit Tests

Unit tests for {{ driver_name }} with mocked API responses.

ðŸ¤– AUTO-GENERATED by Driver Creator Agent
"""

import pytest
from unittest.mock import Mock, patch, MagicMock
import requests

from {{ driver_name }} import {{ driver_class }}
from {{ driver_name }}.exceptions import (
    AuthenticationError,
    ConnectionError,
    ObjectNotFoundError,
    QuerySyntaxError,
    RateLimitError
)


@pytest.fixture
def mock_response():
    """Create a mock response object"""
    response = Mock()
    response.status_code = 200
    response.headers = {}
    response.json.return_value = {"success": True}
    return response


@pytest.fixture
def client():
    """Create a test client with mocked validation"""
    with patch.object({{ driver_class }}, '_validate_connection'):
        return {{ driver_class }}(
            api_url="{{ base_url }}",
            api_key="test_key_12345"
        )


class TestDriverInitialization:
    """Test driver initialization and configuration"""

    def test_init_with_explicit_credentials(self):
        """Test initialization with explicit credentials"""
        with patch.object({{ driver_class }}, '_validate_connection'):
            client = {{ driver_class }}(
                api_url="{{ base_url }}",
                api_key="test_key"
            )

            assert client.api_url == "{{ base_url }}"
            assert client.api_key == "test_key"
            assert client.timeout == 30
            assert client.max_retries == 3

    def test_init_strips_trailing_slash(self):
        """Test that trailing slash is stripped from api_url"""
        with patch.object({{ driver_class }}, '_validate_connection'):
            client = {{ driver_class }}(
                api_url="{{ base_url }}/",
                api_key="test_key"
            )

            assert client.api_url == "{{ base_url }}"

    @patch.dict('os.environ', {
        '{{ driver_name.upper() }}_API_URL': '{{ base_url }}',
        '{{ driver_name.upper() }}_API_KEY': 'env_test_key'
    })
    def test_from_env_success(self):
        """Test loading credentials from environment"""
        with patch.object({{ driver_class }}, '_validate_connection'):
            client = {{ driver_class }}.from_env()

            assert client.api_url == "{{ base_url }}"
            assert client.api_key == "env_test_key"

    @patch.dict('os.environ', {}, clear=True)
    def test_from_env_missing_url(self):
        """Test error when API URL is missing from environment"""
        with pytest.raises(AuthenticationError) as exc_info:
            {{ driver_class }}.from_env()

        assert "{{ driver_name.upper() }}_API_URL" in str(exc_info.value)

    def test_get_capabilities(self, client):
        """Test get_capabilities returns correct structure"""
        caps = client.get_capabilities()

        assert caps.read is True
        {% if supports_write %}assert caps.write is True{% else %}assert caps.write is False{% endif %}
        {% if query_language %}assert caps.query_language == "{{ query_language }}"{% else %}assert caps.query_language is None{% endif %}
        assert caps.pagination.value == "{{ pagination_style if pagination_style else 'none' }}"


class TestDiscoveryMethods:
    """Test discovery methods (list_objects, get_fields)"""

    @patch('requests.Session.request')
    def test_list_objects_success(self, mock_request, client, mock_response):
        """Test list_objects returns list of objects"""
        mock_response.json.return_value = {
            "objects": ["Object1", "Object2", "Object3"]
        }
        mock_request.return_value = mock_response

        objects = client.list_objects()

        assert isinstance(objects, list)
        assert len(objects) > 0
        mock_request.assert_called_once()

    @patch('requests.Session.request')
    def test_get_fields_success(self, mock_request, client, mock_response):
        """Test get_fields returns field schema"""
        mock_response.json.return_value = {
            "fields": [
                {"name": "id", "type": "string", "required": True},
                {"name": "name", "type": "string", "required": False}
            ]
        }
        mock_request.return_value = mock_response

        fields = client.get_fields("TestObject")

        assert isinstance(fields, dict)
        assert "id" in fields or len(fields) > 0
        mock_request.assert_called_once()

    @patch('requests.Session.request')
    def test_get_fields_object_not_found(self, mock_request, client):
        """Test get_fields raises ObjectNotFoundError for invalid object"""
        # Mock 404 response
        error_response = Mock()
        error_response.status_code = 404
        mock_request.side_effect = requests.HTTPError(response=error_response)

        with patch.object(client, 'list_objects', return_value=["Object1", "Object2"]):
            with pytest.raises(ObjectNotFoundError) as exc_info:
                client.get_fields("NonExistentObject")

            assert "NonExistentObject" in str(exc_info.value)
            assert "available" in str(exc_info.value).lower()


{% if query_language %}
class TestQueryExecution:
    """Test query execution methods"""

    @patch('requests.Session.request')
    def test_read_success(self, mock_request, client, mock_response):
        """Test read() executes query successfully"""
        mock_response.json.return_value = {
            "results": [
                {"id": "1", "name": "Record 1"},
                {"id": "2", "name": "Record 2"}
            ]
        }
        mock_request.return_value = mock_response

        query = "SELECT id, name FROM Object LIMIT 10"
        results = client.read(query)

        assert isinstance(results, list)
        assert len(results) > 0
        mock_request.assert_called_once()

    @patch('requests.Session.request')
    def test_read_with_limit(self, mock_request, client, mock_response):
        """Test read() with limit parameter"""
        mock_response.json.return_value = {"results": []}
        mock_request.return_value = mock_response

        query = "SELECT * FROM Object"
        client.read(query, limit=100)

        # Verify limit was added to query
        call_args = mock_request.call_args
        assert call_args is not None

    @patch('requests.Session.request')
    def test_read_query_syntax_error(self, mock_request, client):
        """Test read() raises QuerySyntaxError for invalid syntax"""
        error_response = Mock()
        error_response.status_code = 400
        error_response.json.return_value = {"message": "Invalid syntax"}
        mock_request.side_effect = requests.HTTPError(response=error_response)

        with pytest.raises(QuerySyntaxError) as exc_info:
            client.read("INVALID QUERY SYNTAX")

        assert "syntax" in str(exc_info.value).lower()
{% endif %}


class TestErrorHandling:
    """Test error handling and retries"""

    @patch('requests.Session.request')
    def test_rate_limit_with_retry(self, mock_request, client, mock_response):
        """Test automatic retry on rate limit (429)"""
        # First call: rate limited
        rate_limit_response = Mock()
        rate_limit_response.status_code = 429
        rate_limit_response.headers = {"Retry-After": "1"}

        # Second call: success
        success_response = Mock()
        success_response.status_code = 200
        success_response.json.return_value = {"objects": []}

        mock_request.side_effect = [
            requests.HTTPError(response=rate_limit_response),
            success_response
        ]

        # Should succeed after retry
        with patch('time.sleep'):  # Skip actual sleep
            result = client.list_objects()

        assert mock_request.call_count == 2

    @patch('requests.Session.request')
    def test_rate_limit_exhausted(self, mock_request, client):
        """Test RateLimitError raised after max retries"""
        rate_limit_response = Mock()
        rate_limit_response.status_code = 429
        rate_limit_response.headers = {"Retry-After": "1"}

        mock_request.side_effect = requests.HTTPError(response=rate_limit_response)

        # Should raise after max_retries
        with patch('time.sleep'):  # Skip actual sleep
            with pytest.raises(RateLimitError) as exc_info:
                client.list_objects()

            assert "retry after" in str(exc_info.value).lower()

    @patch('requests.Session.request')
    def test_authentication_error(self, mock_request):
        """Test AuthenticationError on 401 response"""
        auth_error_response = Mock()
        auth_error_response.status_code = 401
        mock_request.side_effect = requests.HTTPError(response=auth_error_response)

        with pytest.raises(AuthenticationError):
            {{ driver_class }}(
                api_url="{{ base_url }}",
                api_key="invalid_key"
            )

    @patch('requests.Session.request')
    def test_connection_error(self, mock_request):
        """Test ConnectionError on network failure"""
        mock_request.side_effect = requests.ConnectionError("Network error")

        with pytest.raises(ConnectionError):
            {{ driver_class }}(
                api_url="{{ base_url }}",
                api_key="test_key"
            )


class TestUtilityMethods:
    """Test utility and helper methods"""

    def test_get_headers(self, client):
        """Test _get_headers returns correct format"""
        headers = client._get_headers()

        assert "Content-Type" in headers
        assert "Accept" in headers
        {% if "api_key" in auth_methods %}assert "Authorization" in headers{% endif %}

    def test_close(self, client):
        """Test close() cleans up resources"""
        # Should not raise exception
        client.close()

        # Session should be closed
        assert client.session is not None  # Just verify it exists


# Integration-style tests (can be run against real API in CI)

@pytest.mark.integration
class TestIntegration:
    """Integration tests (require real API or mock server)"""

    @pytest.mark.skip(reason="Requires real API endpoint")
    def test_full_workflow(self):
        """Test complete workflow: init â†’ discover â†’ query â†’ close"""
        client = {{ driver_class }}.from_env()

        try:
            # Discovery
            objects = client.list_objects()
            assert len(objects) > 0

            # Schema
            fields = client.get_fields(objects[0])
            assert len(fields) > 0

            {% if query_language %}
            # Query
            results = client.read(f"SELECT * FROM {objects[0]} LIMIT 5")
            assert isinstance(results, list)
            {% endif %}

        finally:
            client.close()
